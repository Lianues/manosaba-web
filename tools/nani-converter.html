<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Naninovel è½¬ JSON è½¬æ¢å™¨</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Microsoft YaHei', sans-serif;
      background: #1a1a2e;
      color: #eee;
      min-height: 100vh;
      padding: 20px;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    h1 {
      text-align: center;
      color: #4a9eff;
      margin-bottom: 20px;
    }
    .settings {
      background: #16213e;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 15px;
    }
    .setting-group label {
      display: block;
      margin-bottom: 5px;
      color: #888;
      font-size: 14px;
    }
    .setting-group input {
      width: 100%;
      padding: 10px;
      background: #0f0f23;
      border: 1px solid #333;
      border-radius: 4px;
      color: #fff;
      font-size: 14px;
    }
    .editor-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      height: 60vh;
    }
    .editor-panel {
      display: flex;
      flex-direction: column;
    }
    .editor-panel h3 {
      margin-bottom: 10px;
      color: #4a9eff;
    }
    textarea {
      flex: 1;
      width: 100%;
      padding: 15px;
      background: #0f0f23;
      border: 1px solid #333;
      border-radius: 8px;
      color: #fff;
      font-family: 'Consolas', monospace;
      font-size: 13px;
      line-height: 1.5;
      resize: none;
    }
    .buttons {
      display: flex;
      gap: 10px;
      margin: 20px 0;
      justify-content: center;
    }
    button {
      padding: 12px 30px;
      background: #4a9eff;
      border: none;
      border-radius: 6px;
      color: #fff;
      font-size: 16px;
      cursor: pointer;
      transition: background 0.2s;
    }
    button:hover {
      background: #357abd;
    }
    button.secondary {
      background: #444;
    }
    button.secondary:hover {
      background: #555;
    }
    .stats {
      background: #16213e;
      padding: 15px;
      border-radius: 8px;
      margin-top: 20px;
    }
    .stats h4 {
      margin-bottom: 10px;
      color: #4a9eff;
    }
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
    }
    .stat-item {
      background: #0f0f23;
      padding: 10px;
      border-radius: 4px;
      text-align: center;
    }
    .stat-item .value {
      font-size: 24px;
      color: #4a9eff;
      font-weight: bold;
    }
    .stat-item .label {
      font-size: 12px;
      color: #888;
    }
    .info-box {
      background: #1e3a5f;
      border-left: 4px solid #4a9eff;
      padding: 15px;
      margin-bottom: 20px;
      border-radius: 0 8px 8px 0;
    }
    .info-box h4 {
      color: #4a9eff;
      margin-bottom: 10px;
    }
    .info-box ul {
      margin-left: 20px;
      color: #aaa;
      font-size: 14px;
    }
    .info-box li {
      margin-bottom: 5px;
    }
    .info-box code {
      background: #0f0f23;
      padding: 2px 6px;
      border-radius: 3px;
      color: #7dd3fc;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ® Naninovel è½¬ JSON è½¬æ¢å™¨</h1>
    
    <div class="info-box">
      <h4>ğŸ“– æ”¯æŒçš„å‘½ä»¤</h4>
      <ul>
        <li><code>@printer Normal.Stream</code> â†’ åˆ‡æ¢åˆ°ç›´æ’­æ¨¡å¼</li>
        <li><code>@printer Normal.Default</code> â†’ åˆ‡æ¢åˆ°é»˜è®¤æ¨¡å¼</li>
        <li><code>@print ".."</code> â†’ å¯¹è¯/æ—ç™½ï¼ˆè‡ªåŠ¨åŒ¹é…è¯­éŸ³ï¼‰</li>
        <li><code>@char Ema.Surprised1 pos:50</code> â†’ æ˜¾ç¤ºç«‹ç»˜ï¼ˆè¡¨æƒ…é¢„è®¾ï¼‰</li>
        <li><code>@char Ema.Normal1,ArmR3 pos:50</code> â†’ ç»„åˆç«‹ç»˜ï¼ˆè¡¨æƒ…+æ‰‹è‡‚ï¼‰</li>
        <li><code>@char SubId:"Middle" Coco.Normal1 pos:50,30 Scale:1.25</code> â†’ ä¸­é—´å±‚ç«‹ç»˜</li>
        <li><code>@hideChars</code> â†’ éšè—æ‰€æœ‰ç«‹ç»˜</li>
        <li><code>@hide MainBackground,Warden</code> â†’ éšè—æŒ‡å®šèƒŒæ™¯æˆ–è§’è‰²</li>
        <li><code>@ResetText</code> â†’ é‡ç½®/æ¸…ç©ºæ–‡æœ¬æ¡†</li>
        <li><code>@bgm "Bgm_XX_X"</code> â†’ BGMæ’­æ”¾</li>
        <li><code>@StopBgm</code> â†’ åœæ­¢BGM</li>
        <li><code>@sfx "Sfx_N"</code> â†’ éŸ³æ•ˆæ’­æ”¾</li>
        <li><code>@back X_Y</code> â†’ ä¸»èƒŒæ™¯</li>
        <li><code>@back X_Y Id:"Stills" pos:X,Y Scale:N</code> â†’ CGé™ç”»</li>
        <li><code>@animate target posX:"60" time:"0.4"</code> â†’ åŠ¨ç”»å‘½ä»¤</li>
        <li><code>@blur "MainBackground-Middle" time:0</code> â†’ æ¨¡ç³Šæ•ˆæœ</li>
        <li><code>@Wait "0.2"</code> â†’ ç­‰å¾…å‘½ä»¤ï¼ˆç§’ï¼‰</li>
        <li><code>@goto soft:true Act01_Chapter01/Act01_Chapter01_Adv02</code> â†’ è·³è½¬åœºæ™¯</li>
        <li><code># Label</code> â†’ åœºæ™¯æ ‡ç­¾</li>
      </ul>
    </div>
    
    <div class="settings">
      <div class="setting-group">
        <label>åœºæ™¯ IDï¼ˆè¾“å…¥åè‡ªåŠ¨ç”Ÿæˆè¯­éŸ³è·¯å¾„ï¼‰</label>
        <input type="text" id="sceneId" value="Act01_Chapter01_Adv02" placeholder="åœºæ™¯å”¯ä¸€æ ‡è¯†ï¼Œå¦‚ Act01_Chapter01_Adv02" oninput="updateVoicePaths()">
      </div>
      <div class="setting-group">
        <label>è¯­éŸ³åŸºç¡€è·¯å¾„ï¼ˆè‡ªåŠ¨ç”Ÿæˆï¼Œå¯æ‰‹åŠ¨ä¿®æ”¹ï¼‰</label>
        <input type="text" id="voiceBasePath" value="/Audio/Voice/Act01_Chapter01/Act01_Chapter01_Adv02" placeholder="è¯­éŸ³æ–‡ä»¶æ‰€åœ¨ç›®å½•">
      </div>
      <div class="setting-group">
        <label>è¯­éŸ³æ–‡ä»¶å‰ç¼€ï¼ˆè‡ªåŠ¨ç”Ÿæˆï¼Œå¯æ‰‹åŠ¨ä¿®æ”¹ï¼‰</label>
        <input type="text" id="voicePrefix" value="0101Adv02" placeholder="å¦‚ 0101Adv02">
      </div>
    </div>

    <div class="editor-container">
      <div class="editor-panel">
        <h3>ğŸ“„ Naninovel è„šæœ¬ (.nani)</h3>
        <textarea id="naniInput" placeholder="ç²˜è´´ .nani æ–‡ä»¶å†…å®¹..."></textarea>
      </div>
      <div class="editor-panel">
        <h3>ğŸ“¤ JSON è¾“å‡º</h3>
        <textarea id="jsonOutput" readonly placeholder="è½¬æ¢ç»“æœå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ..."></textarea>
      </div>
    </div>

    <div class="buttons">
      <button onclick="convert()">ğŸ”„ è½¬æ¢</button>
      <button class="secondary" onclick="copyOutput()">ğŸ“‹ å¤åˆ¶ JSON</button>
      <button class="secondary" onclick="downloadOutput()">ğŸ’¾ ä¸‹è½½ JSON</button>
    </div>

    <div class="stats" id="stats" style="display: none;">
      <h4>ğŸ“Š è½¬æ¢ç»Ÿè®¡</h4>
      <div class="stats-grid" id="statsGrid"></div>
    </div>
  </div>

  <script>
/**
 * æ ¹æ®åœºæ™¯ ID è‡ªåŠ¨ç”Ÿæˆè¯­éŸ³è·¯å¾„
 * ä¾‹å¦‚ï¼š
 * - Act01_Chapter01_Adv02 -> /Audio/Voice/Act01_Chapter01/Act01_Chapter01_Adv02, 0101Adv02
 * - Act02_Chapter03_Adv05 -> /Audio/Voice/Act02_Chapter03/Act02_Chapter03_Adv05, 0203Adv05
 */
function updateVoicePaths() {
  const sceneId = document.getElementById('sceneId').value.trim();
  
  // åŒ¹é…åœºæ™¯ ID æ ¼å¼: Act01_Chapter01_Adv02 æˆ– Act01_Chapter01_Trial01 ç­‰
  const match = sceneId.match(/^(Act(\d+))_(Chapter(\d+))_(\w+)(\d+)$/i);
  
  if (match) {
    const actPart = match[1];      // Act01
    const actNum = match[2];       // 01
    const chapterPart = match[3];  // Chapter01
    const chapterNum = match[4];   // 01
    const sceneType = match[5];    // Adv, Trial, etc.
    const sceneNum = match[6];     // 02
    
    // ç”ŸæˆåŸºç¡€è·¯å¾„: /Audio/Voice/Act01_Chapter01/Act01_Chapter01_Adv02
    const folderName = `${actPart}_${chapterPart}`;
    const voiceBasePath = `/Audio/Voice/${folderName}/${sceneId}`;
    
    // ç”Ÿæˆå‰ç¼€: 0101Adv02 (å– act å’Œ chapter çš„æ•°å­—éƒ¨åˆ†ï¼ŒsceneNum ä¿æŒåŸæ ·ä¸è¡¥é›¶)
    const voicePrefix = `${actNum.padStart(2, '0')}${chapterNum.padStart(2, '0')}${sceneType}${sceneNum}`;
    
    document.getElementById('voiceBasePath').value = voiceBasePath;
    document.getElementById('voicePrefix').value = voicePrefix;
  } else {
    // å¦‚æœæ ¼å¼ä¸åŒ¹é…ï¼Œæ¸…ç©ºå¹¶è®©ç”¨æˆ·æ‰‹åŠ¨è¾“å…¥
    document.getElementById('voiceBasePath').value = '';
    document.getElementById('voicePrefix').value = '';
  }
}

// é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', function() {
  updateVoicePaths();
});

// è§’è‰²åæ˜ å°„è¡¨
const CHARACTER_MAP = {
  'Ema': 'æ¨±ç¾½è‰¾ç›',
  'Hiro': 'äºŒé˜¶å ‚å¸Œç½—',
  'Warden': 'å…¸ç‹±é•¿',
  'Unknown': '???',
  'Coco': 'æ³½æ¸¡å¯å¯',
  'Hanna': 'è¿œé‡æ±‰å¨œ',
  'Miria': 'ä½ä¼¯ç±³è‰äºš',
  'Alisa': 'ç´«è—¤äºšé‡Œæ²™',
  'AnAn': 'å¤ç›®å®‰å®‰',
  'Leia': 'è²è§è•¾é›…',
  'Margo': 'å®ç”Ÿç›æ ¼',
  'Meruru': 'å†°ä¸Šæ¢…éœ²éœ²',
  'Nanoka': 'é»‘éƒ¨å¥ˆå¶é¦™',
  'Noah': 'åŸå´è¯ºäºš',
  'Sherry': 'æ©˜é›ªè‰',
};

// è§’è‰²ç«‹ç»˜åŸºç¡€è·¯å¾„æ˜ å°„ï¼ˆæ–°çš„ç»„åˆç³»ç»Ÿï¼‰
const CHARACTER_BASE_PATH = {
  'Ema': '/Characters/Ema',
  'Hiro': '/Characters/Hiro',
  'Warden': '/Characters/Warden',
  'Alisa': '/Characters/Alisa',
  'AnAn': '/Characters/AnAn',
  'Coco': '/Characters/Coco',
  'Hanna': '/Characters/Hanna',
  'Leia': '/Characters/Leia',
  'Margo': '/Characters/Margo',
  'Meruru': '/Characters/Meruru',
  'Miria': '/Characters/Miria',
  'Nanoka': '/Characters/Nanoka',
  'Noah': '/Characters/Noah',
  'Sherry': '/Characters/Sherry',
};

// æ”¯æŒçš„è§’è‰²åˆ—è¡¨ï¼ˆç”¨äºéªŒè¯ï¼‰
const SUPPORTED_CHARACTERS = ['Ema', 'Hiro', 'Warden', 'Alisa', 'AnAn', 'Coco', 'Hanna', 'Leia', 'Margo', 'Meruru', 'Miria', 'Nanoka', 'Noah', 'Sherry'];

// SFX è·¯å¾„æ˜ å°„ (Nani ID -> å®é™…æ–‡ä»¶å)
const SFX_MAP = {
  'Sfx_1': 'Sfx_Scenario_001 Wake up.ogg',
  'Sfx_3': 'Sfx_Scenario_003 Monitor.ogg',
  'Sfx_4': 'Sfx_Scenario_004 Lock prison.ogg',
  'Sfx_5': 'Sfx_Scenario_005 Hikizuru oto.ogg',
  'Sfx_6': 'Sfx_Scenario_006 Fall down.ogg',
  'Sfx_18': 'Sfx_Scenario_018 Reject shake hands.ogg',
  'Sfx_178': 'Sfx_Scenario_178 Landing sound.ogg',
  // Common SFX
  'Sfx_Common_1': 'Sfx_Common_001 Notice1.ogg',
  'Sfx_Common_2': 'Sfx_Common_002 Notice2.ogg',
  'Sfx_Common_3': 'Sfx_Common_003 Decision.ogg',
  'Sfx_Common_4': 'Sfx_Common_004 Hit.ogg',
  'Sfx_Common_5': 'Sfx_Common_005 Conversion.ogg',
  'Sfx_Common_6': 'Sfx_Common_006 Be shocked.ogg',
  'Sfx_Common_7': 'Sfx_Common_007 Negative down.ogg',
};

/**
 * å°† SFX ID è½¬æ¢ä¸ºå®é™…è·¯å¾„
 * @param sfxId å¦‚ "Sfx_1", "Sfx_178"
 */
function convertSfxPath(sfxId) {
  // å…ˆæ£€æŸ¥æ˜ å°„è¡¨
  if (SFX_MAP[sfxId]) {
    const fileName = SFX_MAP[sfxId];
    if (fileName.startsWith('Sfx_Common')) {
      return `/Audio/SFX/Common/${fileName}`;
    } else {
      return `/Audio/SFX/Scenario/${fileName}`;
    }
  }
  
  // å°è¯•è‡ªåŠ¨è§£æ Sfx_N æ ¼å¼
  const match = sfxId.match(/^Sfx_(\d+)$/);
  if (match) {
    const num = match[1].padStart(3, '0');
    // é»˜è®¤å‡è®¾æ˜¯ Scenario ç±»å‹ï¼Œæ–‡ä»¶åæœªçŸ¥
    return `/Audio/SFX/Scenario/Sfx_Scenario_${num}.ogg`;
  }
  
  return `/Audio/SFX/${sfxId}.ogg`;
}

/**
 * å°† Nani èƒŒæ™¯ID è½¬æ¢ä¸ºå®é™…æ–‡ä»¶è·¯å¾„
 */
function convertBackgroundPath(bgId, bgType = 'MainBackground') {
  const match = bgId.match(/^(\d+)_(\d+)$/);
  if (!match) {
    return `/Background/${bgType}/RGB/${bgId}.png`;
  }
  
  const [, major, minor] = match;
  const paddedMajor = major.padStart(3, '0');
  const paddedMinor = minor.padStart(3, '0');
  
  if (bgType === 'Stills') {
    return `/Background/Stills/RGB/Still_${paddedMajor}_${paddedMinor}.png`;
  } else if (bgType === 'Tricks') {
    return `/Background/Tricks/RGB/Trick_${paddedMajor}_${paddedMinor}.png`;
  } else {
    return `/Background/MainBackground/RGB/Background_${paddedMajor}_${paddedMinor}.png`;
  }
}

/**
 * è§£æ @char å‘½ä»¤ï¼Œè¿”å›è§’è‰²å‘½ä»¤å¯¹è±¡
 * æ”¯æŒæ–°çš„ç»„åˆç³»ç»Ÿè¯­æ³•ï¼š
 * - @char Ema.Surprised1 pos:50 -> è§’è‰² + è¡¨æƒ…é¢„è®¾
 * - @char Ema.Normal1,ArmR3 pos:50 -> è§’è‰² + è¡¨æƒ… + æ‰‹è‡‚
 * - @char Hiro.Head1,Pale1-Off,... pos:45 -> å®Œæ•´ç»„åˆè·¯å¾„
 * - @char SubId:"Middle" Warden.1 Scale:1.4 -> ä¸­é—´å±‚è§’è‰²ï¼ˆå•å¼ ç«‹ç»˜ï¼‰
 * - @char SubId:"Middle" Coco.Normal1 pos:50,30 Scale:1.25 -> ä¸­é—´å±‚è§’è‰²ï¼ˆç»„åˆç«‹ç»˜ï¼‰
 * - @char SubId:"Middle" Nanoka pos:50,30 Scale:1.25 -> ä¸­é—´å±‚è§’è‰²ï¼ˆé»˜è®¤å¤–è§‚ï¼‰
 */
function parseCharCommand(line) {
  // æ£€æŸ¥æ˜¯å¦æ˜¯ SubId ç±»å‹çš„è§’è‰²ï¼ˆä¸­é—´å±‚ç«‹ç»˜ï¼‰
  if (line.includes('SubId:')) {
    const subIdMatch = line.match(/SubId:"([^"]+)"/);
    // æ”¯æŒ Warden.1 æˆ– Coco.Normal1 æˆ–çº¯è§’è‰²å Nanoka è¿™æ ·çš„æ ¼å¼
    // æ³¨æ„ï¼šå¤–è§‚å‚æ•°å¯èƒ½åŒ…å«è¿å­—ç¬¦ï¼Œå¦‚ Option-ArmL-Off
    const charWithAppearanceMatch = line.match(/([A-Za-z]+)\.([A-Za-z0-9_,\-]+)/);
    const charOnlyMatch = line.match(/SubId:"[^"]+"\s+([A-Za-z]+)(?:\s|$)/);
    const scaleMatch = line.match(/Scale:([\d.]+)/);
    // è§£æ pos:X,Y æˆ– pos:X æ ¼å¼
    const posMatch = line.match(/pos:(-?[\d.]+)(?:,(-?[\d.]+))?/);
    
    let charId, appearanceStr;
    
    if (charWithAppearanceMatch) {
      charId = charWithAppearanceMatch[1];   // "Coco"
      appearanceStr = charWithAppearanceMatch[2];  // "Normal1" æˆ– "1" æˆ– "Normal1,ArmL2"
    } else if (charOnlyMatch && subIdMatch) {
      charId = charOnlyMatch[1];  // "Nanoka"
      appearanceStr = 'Default';  // é»˜è®¤å¤–è§‚
    } else {
      return null;
    }
    
    if (!subIdMatch) return null;
    
    const subId = subIdMatch[1];  // "Middle"
    const scale = scaleMatch ? parseFloat(scaleMatch[1]) : 1;
    
    const params = {
      id: charId,
      subId: subId,
      scale: scale
    };
    
    // è§£æä½ç½®
    if (posMatch) {
      params.posX = parseFloat(posMatch[1]);
      if (posMatch[2] !== undefined) {
        params.posY = parseFloat(posMatch[2]);
      }
    }
    
    // è§£æå¤–è§‚ç»„åˆ
    const appearance = appearanceStr.split(',').map(s => s.trim()).filter(Boolean);
    params.appearance = appearance;
    
    return {
      type: 'command',
      command: 'charMiddle',
      params: params
    };
  }
  
  // åŒ¹é… @char è§’è‰².[ç»„åˆåˆ—è¡¨] pos:ä½ç½®
  // æ”¯æŒå¤æ‚çš„ç»„åˆè·¯å¾„ï¼ŒåŒ…æ‹¬ Angle01/Head01/... æ ¼å¼
  // æ³¨æ„ï¼šå¤–è§‚å‚æ•°å¯èƒ½åŒ…å«è¿å­—ç¬¦ï¼Œå¦‚ Option-ArmL-Off
  const match = line.match(/@char\s+([A-Za-z]+)(?:\.([^\s]+))?(?:\s+pos:(\d+))?/);
  if (!match) {
    return null;
  }
  
  const charId = match[1];
  const appearanceStr = match[2] || 'Default';
  const position = match[3] ? parseInt(match[3]) : 50;
  
  // æ£€æŸ¥æ˜¯å¦æ˜¯æ”¯æŒçš„è§’è‰²
  if (!SUPPORTED_CHARACTERS.includes(charId)) {
    return null;
  }
  
  // è§£æå¤–è§‚ç»„åˆåˆ—è¡¨
  // å¯ä»¥æ˜¯ç®€å•çš„ "Surprised1" æˆ– "Normal1,ArmR3" æˆ–å®Œæ•´è·¯å¾„
  const appearance = appearanceStr.split(',').map(s => s.trim()).filter(Boolean);
  
  return {
    type: 'command',
    command: 'char',
    params: {
      id: charId,
      appearance: appearance,
      position: position
    }
  };
}

/**
 * è§£æéšè—è§’è‰²å‘½ä»¤
 * @hideChars - éšè—æ‰€æœ‰è§’è‰²
 * @hide Hiro - éšè—æŒ‡å®šè§’è‰²
 */
function parseHideCharsCommand(line) {
  // éšè—æ‰€æœ‰è§’è‰²
  if (line.startsWith('@hideChars')) {
    return {
      type: 'command',
      command: 'hideChars'
    };
  }
  
  // éšè—æŒ‡å®šè§’è‰²æˆ–èƒŒæ™¯: @hide Hiro, MainBackground
  const hideMatch = line.match(/@hide\s+([^\s]+)/);
  if (hideMatch) {
    const id = hideMatch[1];
    return {
      type: 'command',
      command: 'hide',
      params: {
        id: id
      }
    };
  }
  
  return null;
}

/**
 * è§£æé‡ç½®æ–‡æœ¬å‘½ä»¤
 */
function parseResetTextCommand(line) {
  if (line.trim().toLowerCase() === '@resettext') {
    return {
      type: 'command',
      command: 'resetText',
      params: {}
    };
  }
  return null;
}

function parsePrintCommand(line, voiceCounter, options) {
  const textMatch = line.match(/@print\s+"([^"]*)"/);
  if (!textMatch) return null;
  
  let text = textMatch[1];
  text = text.replace(/<br>/g, '\n');
  text = text.replace(/ã€€/g, ' ');
  
  const result = {
    type: 'text',
    text: text
  };
  
  const authorMatch = line.match(/author:"([^"]+)"/);
  if (authorMatch) {
    const authorId = authorMatch[1];
    result.speaker = CHARACTER_MAP[authorId] || authorId;
    
    if (options.voiceBasePath && options.voicePrefix) {
      voiceCounter[authorId] = (voiceCounter[authorId] || 0) + 1;
      const voiceNum = voiceCounter[authorId].toString().padStart(3, '0');
      result.voice = `${options.voiceBasePath}/${options.voicePrefix}_${authorId}${voiceNum}.ogg`;
    }
  }
  
  return result;
}

function parseBgmCommand(line) {
  const match = line.match(/@bgm\s+"([^"]+)"/);
  if (!match) return null;
  
  const bgmId = match[1];
  
  return {
    type: 'command',
    command: 'bgm',
    params: { path: bgmId }  // ç›´æ¥ä¿ç•™ç®€å†™æ ¼å¼ï¼Œè®© game.ts åœ¨è¿è¡Œæ—¶è§£æ
  };
}

function parseStopBgmCommand(line) {
  if (line.trim().toLowerCase() === '@stopbgm') {
    return {
      type: 'command',
      command: 'bgm',
      params: { action: 'stop' }
    };
  }
  return null;
}

/**
 * è§£æ @sfx å‘½ä»¤
 */
function parseSfxCommand(line) {
  const match = line.match(/@sfx\s+"([^"]+)"/);
  if (!match) return null;
  
  const sfxId = match[1];
  const sfxPath = convertSfxPath(sfxId);
  
  return {
    type: 'command',
    command: 'sfx',
    params: { path: sfxPath }
  };
}

/**
 * è§£æ @animate å‘½ä»¤
 * @animate Stills-Middle posX:"60" posY:"-20" easing:"EaseOutBack" time:"0.4"
 */
function parseAnimateCommand(line) {
  const targetMatch = line.match(/@animate\s+([^\s]+)/);
  if (!targetMatch) return null;
  
  const target = targetMatch[1];
  const params = { target };
  const props = {};
  
  // è§£æå¸¦å¼•å·çš„å‚æ•°
  const getQuoted = (key) => {
    const m = line.match(new RegExp(`${key}:"([^"]+)"`));
    return m ? m[1] : null;
  };
  
  const posX = getQuoted('posX');
  const posY = getQuoted('posY');
  const scale = getQuoted('scale');
  const easing = getQuoted('easing');
  const time = getQuoted('time');
  
  if (posX !== null) props.posX = parseFloat(posX);
  if (posY !== null) props.posY = parseFloat(posY);
  if (scale !== null) props.scale = parseFloat(scale);
  
  params.props = props;
  if (easing) params.easing = easing;
  if (time) params.duration = parseFloat(time);
  
  return {
    type: 'command',
    command: 'animate',
    params
  };
}

/**
 * è§£æ @blur å‘½ä»¤
 * @blur "MainBackground-Middle" time:0
 * @blur "MainBackground" power:3 time:0.5
 */
function parseBlurCommand(line) {
  // åŒ¹é…ç›®æ ‡ï¼ˆå¸¦å¼•å·æˆ–ä¸å¸¦å¼•å·ï¼‰
  const targetMatch = line.match(/@blur\s+(?:"([^"]+)"|([^\s]+))/);
  if (!targetMatch) return null;
  
  const target = targetMatch[1] || targetMatch[2];
  const params = { target };
  
  // è§£æ power å‚æ•°ï¼ˆæ¨¡ç³Šå¼ºåº¦ï¼‰
  const powerMatch = line.match(/power:([\d.]+)/);
  if (powerMatch) {
    params.power = parseFloat(powerMatch[1]);
  }
  
  // è§£æ time å‚æ•°
  const timeMatch = line.match(/time:([\d.]+)/);
  if (timeMatch) {
    params.duration = parseFloat(timeMatch[1]);
  }
  
  return {
    type: 'command',
    command: 'blur',
    params
  };
}

// Naninovel é»˜è®¤èƒŒæ™¯ç¼©æ”¾å€¼
const g_backgroundDefaultScale = 1;

function parseBackCommand(line) {
  // æ£€æŸ¥æ˜¯å¦æ˜¯ Stills ç±»å‹
  const isStills = line.includes('Id:"Stills"');
  const isTransparent = line.includes('Transparent');
  const isSolidColor = line.includes('SolidColor');
  
  // åŒ¹é…èƒŒæ™¯ID (å¦‚ 1_1, 490_1)
  const bgIdMatch = line.match(/@back\s+(?:SubId:"[^"]+"\s+)?([\d]+_[\d]+)/);
  
  // å¦‚æœæ—¢æ²¡æœ‰ ID ä¹Ÿæ²¡æœ‰ Transparent/SolidColorï¼Œåˆ™å¯èƒ½æ˜¯çº¯é¢œè‰²æˆ–å…¶ä»–ç‰¹æ®ŠæŒ‡ä»¤
  if (!bgIdMatch && !isTransparent && !isSolidColor) {
    return null;
  }
  
  const params = {};
  
  if (bgIdMatch) {
    const bgId = bgIdMatch[1];
    const bgType = isStills ? 'Stills' : 'MainBackground';
    params.path = convertBackgroundPath(bgId, bgType);
  } else if (isSolidColor) {
    // SolidColor è¡¨ç¤ºçº¯è‰²é®ç½©ï¼ˆé€šå¸¸ç”¨äº Overlay å±‚ï¼‰
    params.path = 'SolidColor';
  } else {
    params.path = null; // é€æ˜/æ¸…ç©ºå±‚
  }
  
  // è§£æ SubId (å±‚çº§)
  const subIdMatch = line.match(/SubId:"([^"]+)"/);
  if (subIdMatch) params.subId = subIdMatch[1];

  // è§£æ tint (è‰²è°ƒ/é®ç½©é¢œè‰²)
  const tintMatch = line.match(/tint:"#?([0-9a-fA-F]+)"/);
  if (tintMatch) params.tint = `#${tintMatch[1]}`;
  
  // è§£æ pos å‚æ•° (pos:X,Y æˆ– pos:X)
  const posMatch = line.match(/pos:\s*(-?[\d.]+)\s*(?:,\s*(-?[\d.]+))?/);
  if (posMatch) {
    params.posX = parseFloat(posMatch[1]);
    if (posMatch[2] !== undefined) {
      params.posY = parseFloat(posMatch[2]);
    }
  }
  
  // è§£æ Scale å‚æ•°
  const scaleExpressionMatch = line.match(/Scale:\{[^}]*?\*\s*([\d.]+)\}/);
  if (scaleExpressionMatch) {
    params.scale = parseFloat(scaleExpressionMatch[1]);
  } else {
    const simpleScaleMatch = line.match(/Scale:\s*(-?[\d.]+)/);
    if (simpleScaleMatch) {
      params.scale = parseFloat(simpleScaleMatch[1]);
    }
  }
  
  // è§£æ Rotation å‚æ•° (Rotation:X,Y,Z)
  const rotationMatch = line.match(/Rotation:([^\s]*)/);
  if (rotationMatch) {
    const rotParts = rotationMatch[1].split(',');
    if (rotParts[0]) params.rotX = parseFloat(rotParts[0]);
    if (rotParts[1]) params.rotY = parseFloat(rotParts[1]);
    if (rotParts[2]) params.rotZ = parseFloat(rotParts[2]);
  }
  
  // è§£æ time å‚æ•°
  const timeMatch = line.match(/time:([\d.]+)/);
  if (timeMatch) {
    params.duration = parseFloat(timeMatch[1]);
  }
  
  return {
    type: 'command',
    command: 'bg',
    params: params
  };
}

/**
 * è§£æ @Wait å‘½ä»¤
 * @Wait "0.2" æˆ– @Wait 0.5
 */
function parseWaitCommand(line) {
  const match = line.match(/@Wait\s+(?:"([^"]+)"|([\d.]+))/i);
  if (!match) return null;
  
  const waitTime = match[1] || match[2];
  
  return {
    type: 'command',
    command: 'wait',
    params: { time: parseFloat(waitTime) }
  };
}

/**
 * è§£æ @goto å‘½ä»¤
 * @goto soft:true Act01_Chapter01/Act01_Chapter01_Adv02
 * @goto Act01_Chapter01/Act01_Chapter01_Adv02
 */
function parseGotoCommand(line) {
  // åŒ¹é… soft å‚æ•°
  const softMatch = line.match(/soft:(true|false)/i);
  const soft = softMatch ? softMatch[1].toLowerCase() === 'true' : false;
  
  // åŒ¹é…åœºæ™¯è·¯å¾„ (æœ€åä¸€ä¸ªå‚æ•°ï¼Œä¸åŒ…å« : çš„éƒ¨åˆ†)
  const parts = line.split(/\s+/);
  let scenePath = null;
  for (let i = parts.length - 1; i >= 0; i--) {
    if (!parts[i].includes(':') && !parts[i].startsWith('@')) {
      scenePath = parts[i];
      break;
    }
  }
  
  if (!scenePath) {
    return null;
  }
  
  return {
    type: 'command',
    command: 'goto',
    params: {
      scene: scenePath,
      soft: soft
    }
  };
}

/**
 * è§£æ @EmoteJumpDouble å‘½ä»¤
 * @EmoteJumpDouble Sherry-Middle -> è§’è‰²ç«‹ç»˜å‘ä¸Šå°è·³ä¸¤ä¸‹
 */
function parseEmoteJumpDoubleCommand(line) {
  const match = line.match(/@EmoteJumpDouble\s+([^\s]+)/i);
  if (!match) return null;
  
  const target = match[1];
  // è§£æç›®æ ‡: Sherry-Middle -> id=Sherry, subId=Middle
  const parts = target.split('-');
  const charId = parts[0];
  const subId = parts.length > 1 ? parts[1] : null;
  
  return {
    type: 'command',
    command: 'emoteJumpDouble',
    params: {
      id: charId,
      subId: subId
    }
  };
}

/**
 * è§£æ @printer å‘½ä»¤
 * @printer Normal.Stream -> åˆ‡æ¢åˆ°ç›´æ’­æ¨¡å¼
 * @printer Normal.Default -> åˆ‡æ¢åˆ°é»˜è®¤æ¨¡å¼
 */
function parsePrinterCommand(line) {
  const match = line.match(/@printer\s+([A-Za-z]+)\.([A-Za-z]+)/i);
  if (!match) return null;
  
  const printerType = match[1]; // Normal
  const appearance = match[2];  // Stream, Default
  
  return {
    type: 'command',
    command: 'printer',
    params: {
      type: printerType,
      appearance: appearance.toLowerCase() // stream, default
    }
  };
}

function parseLabelCommand(line) {
  const match = line.match(/^#\s*(.+)$/);
  if (!match) return null;
  
  return {
    type: 'label',
    name: match[1].trim()
  };
}

function convertNaniToJson(naniContent, options) {
  const lines = naniContent.split(/\r?\n/);
  const scriptLines = [];
  const voiceCounter = {};
  const stats = {
    totalLines: 0,
    dialogues: 0,
    narrations: 0,
    commands: 0,
    backgrounds: 0,
    charCommands: 0,
    sfxCommands: 0,
    voices: {},
  };
  
  for (const rawLine of lines) {
    const line = rawLine.trim();
    if (!line || line.startsWith(';')) continue;
    
    stats.totalLines++;
    let parsed = null;
    
    if (line.startsWith('#')) {
      parsed = parseLabelCommand(line);
    }
    else if (line.startsWith('@char')) {
      parsed = parseCharCommand(line);
      if (parsed) stats.charCommands++;
    }
    else if (line.startsWith('@hideChars') || line.startsWith('@hide ')) {
      parsed = parseHideCharsCommand(line);
      if (parsed) stats.charCommands++;
    }
    else if (line.toLowerCase().startsWith('@resettext')) {
      parsed = parseResetTextCommand(line);
      if (parsed) stats.commands++;
    }
    else if (line.toLowerCase().startsWith('@printer')) {
      parsed = parsePrinterCommand(line);
      if (parsed) stats.commands++;
    }
    else if (line.startsWith('@print')) {
      parsed = parsePrintCommand(line, voiceCounter, options);
      if (parsed) {
        if (parsed.speaker) {
          stats.dialogues++;
        } else {
          stats.narrations++;
        }
      }
    }
    else if (line.startsWith('@bgm')) {
      parsed = parseBgmCommand(line);
      if (parsed) stats.commands++;
    }
    else if (line.toLowerCase().startsWith('@stopbgm')) {
      parsed = parseStopBgmCommand(line);
      if (parsed) stats.commands++;
    }
    else if (line.startsWith('@back')) {
      parsed = parseBackCommand(line);
      if (parsed) stats.backgrounds++;
    }
    else if (line.startsWith('@sfx')) {
      parsed = parseSfxCommand(line);
      if (parsed) stats.sfxCommands++;
    }
    else if (line.startsWith('@animate')) {
      parsed = parseAnimateCommand(line);
      if (parsed) stats.commands++;
    }
    else if (line.startsWith('@blur')) {
      parsed = parseBlurCommand(line);
      if (parsed) stats.commands++;
    }
    else if (line.toLowerCase().startsWith('@wait')) {
      parsed = parseWaitCommand(line);
      if (parsed) stats.commands++;
    }
    else if (line.toLowerCase().startsWith('@goto')) {
      parsed = parseGotoCommand(line);
      if (parsed) stats.commands++;
    }
    else if (line.toLowerCase().startsWith('@emotejumpdouble')) {
      parsed = parseEmoteJumpDoubleCommand(line);
      if (parsed) stats.commands++;
    }
    
    if (parsed) {
      scriptLines.push(parsed);
    }
  }
  
  stats.voices = { ...voiceCounter };
  
  const scene = {
    id: options.sceneId,
    type: options.sceneType || 'traditional',
    lines: scriptLines
  };
  
  return { scene, stats };
}

function convert() {
  const naniInput = document.getElementById('naniInput').value;
  const sceneId = document.getElementById('sceneId').value;
  const voiceBasePath = document.getElementById('voiceBasePath').value;
  const voicePrefix = document.getElementById('voicePrefix').value;
  
  if (!naniInput.trim()) {
    alert('è¯·ç²˜è´´ Naninovel è„šæœ¬å†…å®¹');
    return;
  }
  
  const { scene, stats } = convertNaniToJson(naniInput, {
    sceneId,
    sceneType: 'traditional',
    voiceBasePath,
    voicePrefix
  });
  
  document.getElementById('jsonOutput').value = JSON.stringify(scene, null, 2);
  
  // æ˜¾ç¤ºç»Ÿè®¡
  const statsDiv = document.getElementById('stats');
  const statsGrid = document.getElementById('statsGrid');
  statsDiv.style.display = 'block';
  
  let statsHtml = `
    <div class="stat-item">
      <div class="value">${scene.lines.length}</div>
      <div class="label">æ€»æ¡ç›®æ•°</div>
    </div>
    <div class="stat-item">
      <div class="value">${stats.dialogues}</div>
      <div class="label">å¯¹è¯</div>
    </div>
    <div class="stat-item">
      <div class="value">${stats.narrations}</div>
      <div class="label">æ—ç™½</div>
    </div>
    <div class="stat-item">
      <div class="value">${stats.backgrounds}</div>
      <div class="label">èƒŒæ™¯åˆ‡æ¢</div>
    </div>
    <div class="stat-item">
      <div class="value">${stats.charCommands}</div>
      <div class="label">ç«‹ç»˜å‘½ä»¤</div>
    </div>
    <div class="stat-item">
      <div class="value">${stats.commands}</div>
      <div class="label">BGMå‘½ä»¤</div>
    </div>
    <div class="stat-item">
      <div class="value">${stats.sfxCommands}</div>
      <div class="label">SFXéŸ³æ•ˆ</div>
    </div>
  `;
  
  for (const [char, count] of Object.entries(stats.voices)) {
    const charName = CHARACTER_MAP[char] || char;
    statsHtml += `
      <div class="stat-item">
        <div class="value">${count}</div>
        <div class="label">${charName} è¯­éŸ³</div>
      </div>
    `;
  }
  
  statsGrid.innerHTML = statsHtml;
}

function copyOutput() {
  const output = document.getElementById('jsonOutput');
  output.select();
  document.execCommand('copy');
  alert('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
}

function downloadOutput() {
  const output = document.getElementById('jsonOutput').value;
  if (!output) {
    alert('è¯·å…ˆè½¬æ¢');
    return;
  }
  
  const sceneId = document.getElementById('sceneId').value || 'scene';
  const blob = new Blob([output], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${sceneId}.json`;
  a.click();
  URL.revokeObjectURL(url);
}
  </script>
</body>
</html>
